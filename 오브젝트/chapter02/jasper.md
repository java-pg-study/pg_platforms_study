- 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민

    - 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것

    - 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정

- 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 함

    - 다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적인 존재

    - 설계를 유연하고 확장 가능하게 만듬

### 도메인의 구조를 따르는 프로그램 구조

- 객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문

- 일반적으로 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 한다

- 클래스 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다

### 클래스 구현하기

- 클래스를 구현하거나 다른 개발자에 의해 개발된 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것

- 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것

- 경계의 명확성이 객체의 자율성을 보장, 프로그래머에게 구현의 자유를 제공

#### 자율적인 객체

- 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재라는 것

- 객체가 스스로 판단하고 행동하는 자율적인 존재

- 객체지향은 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음으로써 문제 영역의 아이디어를 적절하게 표현할 수 있게 함

- 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화

- 외부에서의 접근을 통제할 수 있는 접근 제어(access control) 매커니즘도 제공

- 접근 제어를 위해 public, protected, private과 같은 접근 수정자(access modifier)를 제공

- 객체지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것

- 외부에서는 객체가 어떤 상태에 놓여 있는지, 어떤 생각을 하고 있는지 알아서는 안 되며, 결정에 직접적으로 개입하려고 해서도 안 된다

- 객체에게 원하는 것을 요청하고는 객체가 스스로 최선의 방법을 결정할 수 있을 것이라는 점을 믿고 기다려야 함

- 외부에서 접근 가능한 부분 -> 퍼블릭 인터페이스(public interface)

- 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분 -> 구현(implementation)

- 인터페이스와 구현의 분리 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙

### 협력하는 객체들의 공동체

- 객체지향 프로그램을 작성할 때는 먼저 협력의 관점에서 어떤 객체가 필요한지를 결정하고, 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성

- 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청(request)할 수 있다

- 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답(response)한다

- 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메서지를 전송(send a message)하는 것

- 다른 객체에게 요청이 도착할 때 해당 객체가 메시지를 수신(receive a message)했다고 이야기 함

- 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리항 방법을 결정

- 이처럼, 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드(method)라고 부름

- 메시지와 메서드를 구분하는 것은 매우 중요 -> 다형성

## 상속과 다형성

### 컴파일 시간 의존성과 실행 시간 의존성

- 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다

- 클래스 사이의 의존성과 객체 사이의 의존성을 동일하지 않을 수 있다

- 유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것

- 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워짐

- 코드를 이해하기 위해서는 코드뿐만 아니라 객체를 생성하고 연결하는 부분을 찾아야 하기 때문

- 반면 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연해지고 확장 가능해짐

- -> 의존성의 양면성은 설계가 트레이드오프의 산물이라는 사실을 잘 보여줌

- 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다는 사실을 기억

- 반면 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다는 사실도 기억

### 차이에 의한 프로그래밍

- 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽게 빠르게 만드는 방법을 차이에 의한 프로그래밍(programming by difference)이라고 부름

### 상속과 인터페이스

- 상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문

- 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(upcasting)이라고 부름

### 다형성

- 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 함

- 다형성은 컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용해 서로 다른 메서드를 실행할 수 있게 함

- 다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미 -> 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해

## 추상화와 유연성

- 추상화의 장점

    - 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다

    - 추상화를 이용하면 설계가 좀 더 유연해진다

- 추상화의 특징은 세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있게 함

### 상속

- 상속의 문제점

    - 캡슐화 위반 : 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화

    - 캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률이 높인다 -> 상속을 과도하게 사용한 코드는 변경하기도 어려워진다

    - 설계가 유연하지 않다 : 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정

### 합성

- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라고 함

