# 객체 분해

- 추상화 : 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업

- 분해 : 큰 문제를 해결 가능한 작은 문제로 나누는 작업

## 프로시저 추상화와 데이터 추상화

- 현대적인 프로그래밍 언어를 특징 짓는 중요한 두 가지 추상화 메커니즘은 프로시저 추상화(procedure abstraction)와 데이터 추상화(data abstraction)이다.

    - 프로시저 추상화 : 소프트웨어가 무엇을 해야 하는지를 추상화

    - 데이터 추상화 : 소프트웨어가 무엇을 알아야 하는지를 추상화

    - 소프트웨어는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 데이터를 조작한다

- 프로시저 추상화, 기능 분해(functional decomposition), 알고리즘 분해(algorithmic decomposition)

- 데이터 추상화 

    - 데이터를 중심으로 타입을 추상화(type abstraction) -> 추상 데이터 타입(Abstract Data Type)

    - 데이터를 중심으로 프로시저를 추상화(procedure abstraction) -> 객체지향(Object-Oriented)

- 객체지향 패러다임 : 역할과 책임을 수행하는 자율적인 객체들의 협력 공동체를 구축하는 것


## 프로시저 추상화와 기능 분해

### 메인 함수로서의 시스템

- 프로시저는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법

- 하향식 접근법(Top-Down Approach)

### 급여 관리 시스템

- 기능 분해의 결과는 최상위 기능을 수행하는 데 필요한 절차들을 실행되는 시간 순서에 따라 나열한 것

### 급여 관리 시스템 구현

### 하향식 기능 분해의 문제점

- 설계는 코드 배치 방법이며 설계가 필요한 이유는 변경에 대비하기 위한 것

- 변경은 성공적인 소프트웨어가 맞이해야 하는 피할 수 없는 운명

- 현재의 요구사항이 변하지 않고 코드를 변경할 필요가 없다면 소프트웨어를 어떻게 설계하건 아무도 신경 쓰지 않을 것

#### 하나의 메인 함수라는 비현실적인 아이디어

#### 메인 함수의 빈번한 재설계

- 시스템은 여러개의 정상으로 구성되기 때문에 새로운 정상을 추가할 때마다 하나의 정상이라고 간주햇던 main 함수의 내부 구현을 수정할 수 밖에 없다

- 결과적으로 기존 코드의 빈번한 수정으로 인한 버그 발생 확률이 높아지기 때문에 시스템은 변경에 취약해질 수밖에 없다

#### 비즈니스 로직과 사용자 인터페이스의 결합

#### 성급하게 결정된 실행 순서

- 설계를 시작하는 시점부터 시스템이 무엇(what)을 해야 하는지가 아니라 어떻게(how) 동작해야 하는지에 집중하도록 만듬

#### 데이터 번경으로 인한 파급효과

- 데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 함

- 데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고 외부에서는 제공되는 함수만 이용해 데이터에 접근 -> 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제


## 모듈

### 정보 은닉과 모듈

- 시스템의 변경을 관리하는 기본적인 전략은 함께 변경되는 부분을 하나의 구현 단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것

    - 기능을 기반으로 시스템을 분해하는 것이 아니라 변경의 방향에 맞춰 시스템을 분해하는 것

- 정보 은닉 : 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리

    - 모듈은 변경될 가능성이 있는 비밀을 내부로 감추고, 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공해서 내부의 비밀에 함부로 접근하지 못하게 함

    - 복잡성 : 모듈이 너무 복잡한 경우 이해하고 사용하기가 어렵다. 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다

    - 변경 가능성 : 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다. 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계
    결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.

### 모듈의 장점과 한계

- 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다

- 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다

- 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다. 각 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합


## 데이터 추상화와 추상 데이터 타입

### 추상 데이터 타입


