# 메시지와 인터페이스

- 훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향해야 한다

    - 협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 한다

    - 책임이 객체가 수신할 수 있는 메시지의 기반

- 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성


## 협력과 메시지

### 클라이언트-서버 모델

### 메시지와 메시지 전송

- 메시지 : 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단

- 메시지 전송은 메시지 수신자, 오퍼레이션명, 인자의 조합

### 메시지와 메서드

- 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려 있다

- 메서드 : 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저

- 코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다

- 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다

- 메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다 -> 유연하고 확장 가능한 코드를 작성할 수 있게 만든다

### 퍼블릭 인터페이스와 오퍼레이션

- 퍼블릭 인터페이스 : 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합

- 오퍼레이션 : 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지
    
    - 수행 가능한 어떤 행동에 대한 추상화, 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분

### 시그니처

- 시그니처 : 오퍼레이션(또는 메서드)의 이름과 파라미터 목록


## 인터페이스와 설계 품질

- 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 한다

    - 최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함

    - 추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지를 표현

- 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법

    - 디미터 법칙

    - 묻지 말고 시켜라

    - 의도를 드러내는 인터페이스

    - 명령-쿼리 분리

### 디미터 법칙

- 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙 

- 디미터 법칙을 간단하게 요약하면 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것

- "오직 하나의 도트만 사용하라(user only one dot)"

- 객체들의 협력 경로를 제한하면 결합도를 효과적으로 낮출 수 있다

- 디미터 법칙을 따르기 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍

    - this 객체

    - 메서드의 매개변수

    - this의 속성

    - this의 속성인 컬렉션의 요소

    - 메서드 내에서 생성된 지역 객체

- 디미터 법칙을 따르는 코드는 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다

- 디미터 법칙을 따르도록 코드를 개선하면 메시지 전송자는 더 이상 메시지 수신자의 내부 구조에 관해 묻지 않게 된다

    - 단지 자신이 원하는 것이 무엇인지를 명시하고 단순히 수행하도록 요청

- 디미터 법칙은 객체의 내부 구조를 묻는 메시지가 아니라 수신자에게 무언가를 시키는 메시지가 더 좋은 메시지라고 속삭인다

### 묻지 말고 시켜라

- 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다

    - 메시지 수신자가 담당해야 할 책임

- 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반

- 묻지 말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다 -> 응집력 증가

- 객체지향의 기본은 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것

- 묻지 말고 시켜라 원칙을 따르면 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다

- 묻지 말고 시켜라 원칙에 따르듀록 메시지를 결정하다 보면 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다

- 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라

- 협력을 설계하고 객체가 수신할 메시지를 결정하는 매 순간 묻지 말고 시켜라 원칙과 디미터 법칙을 머릿속에 떠올리는 것은 퍼블릭 인터페이스의 품질을 향상시킬 수 있는 좋은 습관

### 의도를 드러내는 인터페이스

- 메서드의 이름을 짓는 방법은 '어떻게'가 아니라 '무엇'을 하는지를 드러내는 것

- 무엇을 하는지를 드러내는 이름은 코드를 읽고 이해하기 쉽게 만들뿐만 아니라 유연한 코드를 낳는 지름길이다

- 어떻게 수행하는지를 드러내는 이름이란 메서드의 내부 구현을 설명하는 이름

    - 결과적으로 협력을 설계하기 시작하는 이른 시기부터 클래스의 내부 구현에 관해 고민할 수 밖에 없다

- 무엇을 하는지를 드러내도록 메서드의 이름을 짓기 위해서는 객체가 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다

- 메서드가 어떻게 수행하느냐가 아니라 무엇을 하느냐에 초점을 맞추면 클라이언트의 관점에서 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다

    - 다양한 타입의 객체가 참여할 수 있는 유연한 협력을 얻게 되는 것

- 의도를 드러내는 선택자(Intention Revealing Selector)

### 함께 모으기 

- 근본적으로 디미터 법칙을 위반하는 설계는 인터페이스와 구현의 분리 원칙을 위반

- 오퍼레이션의 이름은 협력이라는 문맥을 반영

    - 오퍼레이션은 클라이언트가 객체에게 무엇을 원하는지를 표현해야 한다

    - 객체 자신이 아닌 클라이언트의 의도를 표현하는 이름을 가져야 한다

- 디미터 법칙은 객체 간의 협력을 설계할 때 캡슐화를 위반하는 메시지가 인터페이스에 포함되지 않도록 제한

- 묻지 말고 시켜라 원칙은 디미터 법칙을 준수하는 협력을 만들기 위한 스타일을 제시

- 의도를 드러내는 인터페이스 원칙은 객체의 퍼블릭 인터페이스에 
어떤 이름이 드러나야 하는지에 대한 지침을 제공함으로써 코드의 목적을 명확하게 커뮤니케이션할 수 있게 해줌


## 원칙의 함정

### 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다

### 결합도와 응집도의 충돌

- 위임 메서드를 통해 객체의 내부 구조를 감추는 것은 협력에 참여하는 객체들의 결합도를 낮출 수 있는 동시에 객체의 응집도를 높일 수 있는 가장 효과적인 방법

- 하지만 묻지 말고 시켜라와 디미터 법칙을 준수하는 것이 항상 긍정적인 결과로만 귀결되는 것은 아니다

- 모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 됨

    - => 객체는 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 결과적으로 응집도가 낮아짐

- 클래스는 하나의 변경 원인만을 가져야 함

    - 서로 상관없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮으며 작은 변경으로도 쉽게 무너질 수 있음


## 명령-쿼리 분리 원칙

- 프로시저 : 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다 -> 명령(command)

- 함수 : 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다 -> 쿼리(query)

- 명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것

    - 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안 된다

- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다

- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다

- 이런 스타일의 인터페이스를 사용함으로써 객체의 캡슐화와 다양한 문맥에서의 재사용을 보장할 수 있다

### 반복 일정의 명령과 쿼리 분리하기

- 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있다

- 퍼블릭 인터페이스를 설계할 때 부수효과를 가지는 대신 값을 반환하지 않는 명령과, 부수효과를 가지지 않는 대신 값을 반환하는 쿼리를 분리하자

    - 코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해질 것이다

### 명령-쿼리 분리와 참조 투명성

- 명령과 쿼리를 엄격하게 분류하면 객체의 부수효과를 제어하기가 수월해짐

    - 쿼리는 객체의 상태를 변경하지 않기 때문에 몇 번이고 반복적으로 호출하더라도 상관 없음

    - 명령이 개입하지 않는 한 쿼리의 값은 변경되지 않기 때문에 쿼리의 결과를 예측하기 쉬워짐

    - 쿼리들의 순서를 자유롭게 변경할 수 있음

- 참조 투명성이라는 특성을 잘 활용하면 버그가 적고, 디버깅이 용이하며, 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성할 수 있다

- 어떤 값이 변하지 않는 성질 => 불변성, 어떤 값이 불변한다는 말은 부수효과가 발생하지 않는다

### 책임에 초점을 맞춰라

- 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택

- 객체의 구현 이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 만든다

- 디미터 법칙 : 협력이라는 컨텍스트 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다.
    수신할 객체를 알지 못한 상태에서 메시지를 먼저 선택하기 때문에 객체의 내부 구조에 대해 고민할 필요가 없어진다. 
    따라서 메시지가 객체를 선택하게 함으로써 의도적으로 디미터 법칙을 위반할 위험을 최소화할 수 있다.

- 묻지 말고 시켜라 : 메시지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다. 
    클라이언트의 관점에서 메시지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메시지를 전송하면 된다.

- 의도를 드러내는 인터페이스 : 메시지를 먼저 선택한다는 것은 메시지를 전송하는 클라이언트의 관점에서 메시지의 이름을 정한다는 것이다.
    당연히 그 이름에는 클라이언트가 무엇을 원하는지, 그 의도가 분명하게 드러날 수 밖에 없다.

- 명령-쿼리 분리 원칙 : 메시지를 먼저 선택한다는 것은 협력이라는 문맥 안에서 객체의 인터페이스에 관해 고민한다는 것을 의미한다.
    객체가 단순히 어떤 일을 해야 하는지뿐만 아니라 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게된다.
    따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.



